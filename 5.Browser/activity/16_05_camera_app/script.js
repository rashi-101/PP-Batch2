//flow
//Task 1 : record video and download it
//video record: we need mediaStream and a mediaRecorder to record it
//fuctioning: start recording when click on record button and save it when record button is clicked again
//prerequiseite to start recording: get Media Stream and media recorder
//when recording is started, you have to keep storing video, for that we'll use data avalilabe event, whenever data is available temporarily store that availabel data is and array
//when recording is stopped, save video
//for downloading anything we have to convert to blob, for that create url of that blob. create and anchor tag, put url in its href and download it using a.download = filename and then a.click

let videoEle = document.querySelector("video");
let audioEle = document.querySelector("audio");
let constraints = {
    video: true,
    audio: true,
}

let mediaRecorder;
//when we'll have a mediaStream with us, we'll inititalise it by putting it equal to new MediaRecorder(stream), by this, we'll know that which stream are we going to record

let recordState = false;
//initially we are not recording anything

let buffer = [];
//video is heavy on storage, since we dont have enough space with us, therefore we'll keep it in a buffer, for now, lets keep it in array. Whatever video we record,
// we'll store it here




// 1. using getUserMedia to ask user what all permissions you require to run your app smoothly on their systems, when valid permissions/constraints are passed in 
//getUserMedia, it produces a mediaStream
//MediaStream objects have a single input and a single output. A MediaStream object generated by getUserMedia() is called local, 
//and has as its source input one of the user's cameras or microphones. A non-local MediaStream may be representing a media element,
// like <video> or <audio>, a stream originating over the network, and obtained via the WebRTC RTCPeerConnection API, or a stream 
//created using the Web Audio API MediaStreamAudioSourceNode.

// mediaDevices.getUserMedia returns a Promise that resolves to a MediaStream object. If the user denies permission, or matching media is not available, then the
//  promise is rejected with NotAllowedError or NotFoundError respectively
navigator.mediaDevices.getUserMedia(constraints).then(function (mediaStream) {
    // alert("received media");

    //srcObject property of htmlMediaElement interface(video tag) and is used to set the source/input of that video, here as source, we are putting in mediaStream returned
    // by getUserMedia promise, i.e. the media that we'll have after taking permissions of devices from user, i.e. our own video. Src can be any file or blob too.
    videoEle.srcObject = mediaStream;
    mediaRecorder = new MediaRecorder(mediaStream);

    //dataavailable event is fired whenever there's some data available in recorder
    mediaRecorder.addEventListener("dataavailable", function (e) {
        //as and when the video is recorded, we are storing that chunk of video, this chunk of video is in Blob form
        buffer.push(e.data);
    });


    mediaRecorder.addEventListener("stop", function () {
        //when recording is stopped, we put our buffer array in blob and mention the type of data it has
        let blob = new Blob(buffer, { type: "video/mp4" });

        //making a url out of blob, so as to download it
        let url = window.URL.createObjectURL(blob);
        let a = document.createElement("a");

        //file.mp4 is the name of the file that will be downloaded
        a.download = "file.mp4";
        a.href = url;
        a.click();
    });
}).catch(function (e) {
    console.log(e);
});

let videoRecorder = document.querySelector("#record-video");


//when record button is toggled, we'll change our record state and start/stop recording our mediaRecorder reference which has our mediaStream
videoRecorder.addEventListener("click", function () {
    if(!mediaRecorder){
        alert("Allow File permissions");
        return;
    }
    if (recordState == false) {
        mediaRecorder.start();
        videoRecorder.innerHTML = "Recording..."
        recordState = true;
    } else {
        mediaRecorder.stop();
        videoRecorder.innerHTML = "Record";
        recordState = false;
    }
});


//Extra info: all video stuff appears under network(xhr) tab in chrome dev tools